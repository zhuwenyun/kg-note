
## Bean的生命周期
1、加载BeanDefinition  
2、实例化Bean对象  
3、初始化Bean对象  
4、使用Bean对象  
5、销毁Bean对象  


## 扩展点与执行时机
### 属性填充阶段
AbstractAutowireCapableBeanFactory#populateBean【入口】  
//返回true会跳过属性填充阶段  
InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation  
autowireByName  
autowireByType  
//返回替换后的属性列表用它来给属性赋值  
InstantiationAwareBeanPostProcessor#postProcessPropertyValues  

### 初始化阶段
AbstractAutowireCapableBeanFactory#initializeBean【入口】  
invokeAwareMethods  
BeanPostProcessor#postProcessBeforeInitialization  
invokeInitMethods  
    InitializingBean#afterPropertiesSet  
    Bean#init-method  
BeanPostProcessor#postProcessAfterInitialization  
    @PostConstructor  


## 补充常见扩展点的定义
### 初始化相关
```java
//①
public interface InitializingBean {
    void afterPropertiesSet() throws Exception;
}
//②
@Documented
@Retention (RUNTIME)
@Target(METHOD)
public @interface PostConstruct {
}
//③
<bean init-method="customerInitMethod" />
```

```java
public interface ApplicationContextAware extends Aware {
    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
}

public interface EnvironmentAware extends Aware {
	void setEnvironment(Environment environment);
}
```

```java
public interface BeanPostProcessor {
    // 初始化前
	Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;
    // 初始化后
	Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
}
```

### 销毁相关
```java
public interface DisposableBean {
	void destroy() throws Exception;
}

@Documented
@Retention (RUNTIME)
@Target(METHOD)
public @interface PreDestroy {
}

<bean destroy-method="customerDestroyMethod" />
```


## AOP创建时机
1、首先我们得认识下BeanPostProcessor的儿子SmartInstantiationAwareBeanPostProcessor它有个特殊方法getEarlyBeanReference它会被
```java
public interface SmartInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessor {
	// 通常返回null
    Class<?> predictBeanType(Class<?> beanClass, String beanName) throws BeansException;
	// 通常返回null
    Constructor<?>[] determineCandidateConstructors(Class<?> beanClass, String beanName) throws BeansException;
	// 通常返回null
    Object getEarlyBeanReference(Object bean, String beanName) throws BeansException;
}
```

2、SmartInstantiationAwareBeanPostProcessor它在Spring中只有唯一的儿子AbstractAutoProxyCreator用户创建代理对象
```java
public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport
		implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware {
    
    @Override
	public Class<?> predictBeanType(Class<?> beanClass, String beanName) {
		if (this.proxyTypes.isEmpty()) {
			return null;
		}
		Object cacheKey = getCacheKey(beanClass, beanName);
		return this.proxyTypes.get(cacheKey);
	}

    @Override
	public Constructor<?>[] determineCandidateConstructors(Class<?> beanClass, String beanName) throws BeansException {
		return null;
	}
    //发生循环依赖时被调用
    @Override
	public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {
		Object cacheKey = getCacheKey(bean.getClass(), beanName);
		//加入缓存
        if (!this.earlyProxyReferences.contains(cacheKey)) {
			this.earlyProxyReferences.add(cacheKey);
		}
		return wrapIfNecessary(bean, beanName, cacheKey);
	}
    //不管是否发生循环依赖都会被调用
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		if (bean != null) {
			Object cacheKey = getCacheKey(bean.getClass(), beanName);
			//缓存中有直接返回
            if (!this.earlyProxyReferences.contains(cacheKey)) {
				return wrapIfNecessary(bean, beanName, cacheKey);
			}
		}
		return bean;
	}

    protected Object getCacheKey(Class<?> beanClass, String beanName) {
		if (StringUtils.hasLength(beanName)) {
			return (FactoryBean.class.isAssignableFrom(beanClass) ?
					BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);
		}
		else {
			return beanClass;
		}
	}
}
```


## Spring如何利用三级缓存解决循环依赖
A依赖B，且B依赖A的场景分析
获取A的流程
1、Spring调用AbstractBeanFactory#getBean
public Object getBean(String name) throws BeansException
2、内部调用AbstractBeanFactory#doGetBean方法
3、依次从一、二、三级缓存中获取单例Bean
Object sharedInstance = getSingleton(beanName);
4、检测一级缓存中是否存在Bean对象
如果不存在
标记对象为创建中
直接执行singletonFactory得到单例Bean对象
singletonObject = singletonFactory.getObject();
标记对象为创建完成
如果是新创建的Bean则加入一级缓存，移除二三级缓存
sharedInstance = getSingleton(beanName, singletonFactory);
思考：singletonFactory中究竟做了什么呢？
调用AbstractAutowireCapableBeanFactory#createBean返回单例Bean

### AbstractBeanFactory#getBean
AbstractBeanFactory#doGetBean

### AbstractAutowireCapableBeanFactory#createBean
//创建对象前可以返回自己创建对象
InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation
//上一步如果返回自己创建对象则会处理，如果返回对象不为空，后面的Spring初始化逻辑就不做了
InstantiationAwareBeanPostProcessor#postProcessAfterInitialization
//上述步骤返回null我们的Spring才会帮我们创建和初始化Bean
AbstractAutowireCapableBeanFactory#doCreateBean
### AbstractAutowireCapableBeanFactory#doCreateBean
//获取构造函数并实例化
createBeanInstance
//单例&允许循环引用&并发创建中，加入三级缓存并标记为创建中
addSingletonFactory
//属性填充
populateBean
//初始化
initializeBean
//单例&允许循环引用&并发创建中，依次从一、二、三级缓存中取Bean
//删除三级缓存，执行ObjectFactory并加入二级缓存
getSingleton
//ObjectFactory中的逻辑，很简单就是创建代理对象
//SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference
getEarlyBeanReference

//第二次会被再次创建吗？
Object bean = instanceWrapper.getWrappedInstance();
//exposedObject是原始Bean
Object exposedObject = bean;
//exposedObject是半成品Bean，
if (exposedObject != null) exposedObject = initializeBean(...);
if (exposedObject == bean) exposedObject = earlySingletonReference;
				
A


```java

```


AbstractBeanFactory#getBean
AbstractBeanFactory#doGetBean

//依次从一、二、三级缓存中取Bean
Object sharedInstance = getSingleton(beanName);
//如果存在，处理下早期暴露的Bean然后返回
if(sharedInstance!=null) bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
//如果不存在，且单例，先执行ObjectFactory然后加入三级缓存
addSingletonFactory


```java
public interface FactoryBean<T> {
	T getObject() throws Exception;
	Class<?> getObjectType();
	boolean isSingleton();
}

public interface ObjectFactory<T> {
	T getObject() throws BeansException;
}

public abstract class AbstractAutowireCapableBeanFactory ...{
    
	protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)
			throws BeanCreationException {
        //...
        addSingletonFactory(beanName, new ObjectFactory<Object>() {
            @Override
            public Object getObject() throws BeansException {
                return getEarlyBeanReference(beanName, mbd, bean);
            }
        });
        //...
    }

    //继承自DefaultSingletonBeanRegistry
    protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
		Assert.notNull(singletonFactory, "Singleton factory must not be null");
		synchronized (this.singletonObjects) {
			if (!this.singletonObjects.containsKey(beanName)) {
				this.singletonFactories.put(beanName, singletonFactory);
				this.earlySingletonObjects.remove(beanName);
				this.registeredSingletons.add(beanName);
			}
		}
	}

    protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
		Object exposedObject = bean;
		if (bean != null && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
					SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
					exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);
					if (exposedObject == null) {
						return null;
					}
				}
			}
		}
		return exposedObject;
	}
}


```




